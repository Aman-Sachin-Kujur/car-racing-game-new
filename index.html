<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Road Rush: Power-Up Edition</title><link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"><style>:root { --player-color: #2563eb; --obstacle-color: #ef4444; --powerup-speed-color: #facc15; --powerup-shield-color: #3b82f6; --powerup-slow-color: #a855f7; }body { font-family: 'Inter', sans-serif; } canvas { touch-action: none; } .game-over-modal { display: none; } .powerup-indicator-container { position: absolute; top: 1rem; right: 1rem; display: flex; flex-direction: column; gap: 0.5rem; }.powerup-indicator { display: flex; align-items: center; background-color: rgba(0, 0, 0, 0.7); color: white; padding: 0.3rem 0.6rem; border-radius: 9999px; font-size: 0.8rem; }.powerup-indicator span { margin-left: 0.4rem; }.powerup-icon { width: 1.2rem; height: 1.2rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: bold; color: white; } .powerup-speed .powerup-icon { background-color: var(--powerup-speed-color); } .powerup-shield .powerup-icon { background-color: var(--powerup-shield-color); } .powerup-slow .powerup-icon { background-color: var(--powerup-slow-color); } .hidden { display: none !important; }</style></head><body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4 relative"><div class="flex flex-col items-center justify-center w-full max-w-lg bg-gray-800 rounded-lg shadow-xl p-6 relative"><h1 class="text-4xl font-extrabold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-indigo-600">Road Rush</h1><div class="mb-6 text-center text-gray-300"><p class="text-lg">Dodge obstacles, grab power-ups, and survive!</p></div><div class="relative w-full aspect-video bg-gray-700 rounded-lg overflow-hidden border-4 border-gray-600"><canvas id="gameCanvas" class="w-full h-full"></canvas><div class="absolute inset-0 flex flex-col items-center justify-center bg-gray-900 bg-opacity-80 p-4" id="gameOverScreen"><h2 class="text-5xl font-extrabold text-red-500 mb-4">Game Over!</h2><p class="text-xl text-gray-200 mb-6">Score: <span id="finalScore" class="font-bold">0</span></p><button id="restartButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition duration-300 transform hover:scale-105">Restart Game</button></div><div class="absolute top-4 left-4 text-2xl font-bold text-white z-10">Score: <span id="scoreDisplay">0</span></div><div class="powerup-indicator-container" id="powerUpIndicators"><div id="speedBoostIndicator" class="powerup-indicator hidden"><div class="powerup-icon">&#9733;</div><span>Speed</span><span class="timer"></span></div><div id="shieldIndicator" class="powerup-indicator hidden"><div class="powerup-icon">&#9787;</div><span>Shield</span><span class="timer"></span></div><div id="slowMotionIndicator" class="powerup-indicator hidden"><div class="powerup-icon">&#9201;</div><span>Slow</span><span class="timer"></span></div></div></div><div class="mt-6 w-full flex justify-between items-center text-gray-400 text-sm"><p>&copy; 2023 Road Rush Dev</p><a href="#" class="text-blue-400 hover:underline" onclick="alert('Use arrow keys or WASD to move. On touch devices, tap left/right half of the screen.')">How to Play</a></div></div><script>const canvas = document.getElementById('gameCanvas');const ctx = canvas.getContext('2d');const gameOverScreen = document.getElementById('gameOverScreen');const restartButton = document.getElementById('restartButton');const scoreDisplay = document.getElementById('scoreDisplay');const finalScore = document.getElementById('finalScore');const powerUpIndicators = document.getElementById('powerUpIndicators');const speedBoostIndicator = document.getElementById('speedBoostIndicator');const shieldIndicator = document.getElementById('shieldIndicator');const slowMotionIndicator = document.getElementById('slowMotionIndicator');let animationFrameId;let gameRunning = false;let score = 0;let lastFrameTime = 0;let deltaTime = 0;let canvasWidth, canvasHeight;let player = { x: 0, y: 0, width: 25, height: 40, baseSpeed: 200, currentSpeed: 200 };let obstacles = [];let powerUps = [];let obstacleSpawnTimer = 0;let powerUpSpawnTimer = 0;let maxObstacles = 4;let obstacleBaseSpeed = 150;let gameSpeedMultiplier = 1; // Used for slow-motion effectconst obstacleTypes = [{ type: 'car', width: 25, height: 40, color: '#ef4444' },{ type: 'truck', width: 40, height: 60, color: '#f97316' },{ type: 'motorcycle', width: 15, height: 30, color: '#8b5cf6' }];const powerUpTypes = [{ type: 'speed', color: 'var(--powerup-speed-color)', icon: '&#9733;' },{ type: 'shield', color: 'var(--powerup-shield-color)', icon: '&#9787;' },{ type: 'slow', color: 'var(--powerup-slow-color)', icon: '&#9201;' }];// Power-up stateslet isShieldActive = false;let shieldTimer = 0;const shieldDuration = 7000;let isSpeedBoostActive = false;let speedBoostTimer = 0;const speedBoostDuration = 5000;let isSlowMotionActive = false;let slowMotionTimer = 0;const slowMotionDuration = 6000;let keys = { ArrowLeft: false, ArrowRight: false, KeyA: false, KeyD: false };let touchX = null;function resizeCanvas() {canvasWidth = canvas.clientWidth;canvasHeight = canvas.clientHeight;canvas.width = canvasWidth;canvas.height = canvasHeight;player.x = canvasWidth / 2 - player.width / 2;player.y = canvasHeight - player.height - 30;}function resetGame() {score = 0;obstacles = [];powerUps = [];obstacleSpawnTimer = 0;powerUpSpawnTimer = 0;isShieldActive = false;shieldTimer = 0;isSpeedBoostActive = false;speedBoostTimer = 0;isSlowMotionActive = false;slowMotionTimer = 0;gameSpeedMultiplier = 1;player.currentSpeed = player.baseSpeed;updatePowerUpIndicators();gameOverScreen.classList.add('hidden');gameRunning = true;if (animationFrameId) {cancelAnimationFrame(animationFrameId);}lastFrameTime = performance.now();animationFrameId = requestAnimationFrame(gameLoop);}function createObstacle() {const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];const width = type.width;const height = type.height;const x = Math.random() * (canvasWidth - width);const speed = obstacleBaseSpeed + score / 50;obstacles.push({ x: x, y: -height, width: width, height: height, speed: speed, color: type.color, type: type.type });}function createPowerUp() {const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];const size = 20;const x = Math.random() * (canvasWidth - size);powerUps.push({ x: x, y: -size, width: size, height: size, speed: obstacleBaseSpeed * 0.8, color: type.color, type: type.type });}function drawPlayer() {ctx.fillStyle = isShieldActive ? 'var(--powerup-shield-color)' : 'var(--player-color)'; // Shield visualctx.fillRect(player.x, player.y, player.width, player.height);}function drawObstacles() {obstacles.forEach(obstacle => {ctx.fillStyle = obstacle.color;ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);});}function drawPowerUps() {powerUps.forEach(powerUp => {ctx.fillStyle = powerUp.color;if (powerUp.type === 'shield') {ctx.beginPath();ctx.arc(powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2, powerUp.width / 2, 0, Math.PI * 2);ctx.fill();} else if (powerUp.type === 'speed') {ctx.font = '16px Arial';ctx.textAlign = 'center';ctx.textBaseline = 'middle';ctx.fillText('★', powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);} else if (powerUp.type === 'slow') {ctx.font = '16px Arial';ctx.textAlign = 'center';ctx.textBaseline = 'middle';ctx.fillText('⌚', powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);} else {ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);}});ctx.strokeStyle = '#fff';ctx.lineWidth = 1;}function updatePlayer(dt) {let moveAmount = player.currentSpeed * dt / 1000;if (keys.ArrowLeft || keys.KeyA) {player.x -= moveAmount;}if (keys.ArrowRight || keys.KeyD) {player.x += moveAmount;}player.x = Math.max(0, Math.min(canvasWidth - player.width, player.x));}function updateObstacles(dt) {obstacles.forEach(obstacle => {obstacle.y += obstacle.speed * dt / 1000 * gameSpeedMultiplier;});obstacles = obstacles.filter(obstacle => obstacle.y < canvasHeight);obstacleSpawnTimer += dt;if (obstacleSpawnTimer > (1000 / (1 + score / 200)) / gameSpeedMultiplier && obstacles.length < maxObstacles) {createObstacle();obstacleSpawnTimer = 0;}}function updatePowerUps(dt) {powerUps.forEach(powerUp => {powerUp.y += powerUp.speed * dt / 1000 * gameSpeedMultiplier;});powerUps = powerUps.filter(powerUp => powerUp.y < canvasHeight);powerUpSpawnTimer += dt;if (powerUpSpawnTimer > (5000 + Math.random() * 5000) / gameSpeedMultiplier) {createPowerUp();powerUpSpawnTimer = 0;}}function checkCollision(obj1, obj2) {return obj1.x < obj2.x + obj2.width && obj1.x + obj1.width > obj2.x &&obj1.y < obj2.y + obj2.height && obj1.y + obj1.height > obj2.y;}function updatePowerUpTimers(dt) {if (isShieldActive) {shieldTimer -= dt;if (shieldTimer <= 0) {isShieldActive = false;shieldTimer = 0;player.currentSpeed = player.baseSpeed;updatePowerUpIndicators();}}if (isSpeedBoostActive) {speedBoostTimer -= dt;if (speedBoostTimer <= 0) {isSpeedBoostActive = false;speedBoostTimer = 0;player.currentSpeed = player.baseSpeed;updatePowerUpIndicators();}}if (isSlowMotionActive) {slowMotionTimer -= dt;if (slowMotionTimer <= 0) {isSlowMotionActive = false;slowMotionTimer = 0;gameSpeedMultiplier = 1;player.currentSpeed = player.baseSpeed;updatePowerUpIndicators();}}updatePowerUpIndicators();}function activatePowerUp(type) {switch (type) {case 'speed':isSpeedBoostActive = true;speedBoostTimer = speedBoostDuration;player.currentSpeed = player.baseSpeed * 1.5; // 50% speed boostbreak;case 'shield':isShieldActive = true;shieldTimer = shieldDuration;break;case 'slow':isSlowMotionActive = true;slowMotionTimer = slowMotionDuration;gameSpeedMultiplier = 0.5; // Half speed for everythingbreak;}updatePowerUpIndicators();}function updatePowerUpIndicators() {function updateIndicator(indicator, active, timer, duration) {if (active) {indicator.classList.remove('hidden');const remainingSeconds = Math.ceil(timer / 1000);indicator.querySelector('.timer').textContent = `(${remainingSeconds}s)`;} else {indicator.classList.add('hidden');}}updateIndicator(speedBoostIndicator, isSpeedBoostActive, speedBoostTimer, speedBoostDuration);updateIndicator(shieldIndicator, isShieldActive, shieldTimer, shieldDuration);updateIndicator(slowMotionIndicator, isSlowMotionActive, slowMotionTimer, slowMotionDuration);}function gameLoop(currentTime) {if (!gameRunning) return;deltaTime = currentTime - lastFrameTime;lastFrameTime = currentTime;ctx.clearRect(0, 0, canvasWidth, canvasHeight);drawPlayer();updatePlayer(deltaTime);updateObstacles(deltaTime);drawObstacles();updatePowerUps(deltaTime);drawPowerUps();updatePowerUpTimers(deltaTime);powerUps = powerUps.filter(powerUp => {if (checkCollision(player, powerUp)) {activatePowerUp(powerUp.type);return false; // Remove power-up}return true;});for (let i = obstacles.length - 1; i >= 0; i--) {const obstacle = obstacles[i];if (checkCollision(player, obstacle)) {if (isShieldActive) {obstacles.splice(i, 1); // Remove obstacle if shieldedisShieldActive = false;shieldTimer = 0;updatePowerUpIndicators();score += 10; // Bonus for shielding a hit} else {endGame();return;}}}score += (deltaTime / 1000) * gameSpeedMultiplier; // Score increases with time, affected by slow-motionscoreDisplay.textContent = Math.floor(score);animationFrameId = requestAnimationFrame(gameLoop);}function endGame() {gameRunning = false;cancelAnimationFrame(animationFrameId);finalScore.textContent = Math.floor(score);gameOverScreen.classList.remove('hidden');}window.addEventListener('resize', resizeCanvas);window.addEventListener('keydown', (e) => {if (keys.hasOwnProperty(e.key)) {keys[e.key] = true;}});window.addEventListener('keyup', (e) => {if (keys.hasOwnProperty(e.key)) {keys[e.key] = false;}});canvas.addEventListener('touchstart', (e) => {e.preventDefault();touchX = e.touches[0].clientX;}, { passive: false });canvas.addEventListener('touchmove', (e) => {e.preventDefault();if (touchX !== null) {const currentX = e.touches[0].clientX;const delta = currentX - touchX;if (Math.abs(delta) > 10) { // Threshold for movementif (delta < 0) { keys.ArrowLeft = true; keys.ArrowRight = false; } else { keys.ArrowLeft = false; keys.ArrowRight = true; }touchX = currentX;} else { keys.ArrowLeft = false; keys.ArrowRight = false; }} else { // Initial touch after some movementif (e.touches[0].clientX < canvasWidth / 2) { keys.ArrowLeft = true; keys.ArrowRight = false; } else { keys.ArrowLeft = false; keys.ArrowRight = true; }touchX = e.touches[0].clientX;}}, { passive: false });canvas.addEventListener('touchend', () => {keys.ArrowLeft = false;keys.ArrowRight = false;touchX = null;});restartButton.addEventListener('click', resetGame);resizeCanvas();resetGame();</script></body></html>